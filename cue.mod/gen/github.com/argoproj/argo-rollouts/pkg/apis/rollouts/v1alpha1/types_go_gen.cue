// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/argoproj/argo-rollouts/pkg/apis/rollouts/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	corev1 "k8s.io/api/core/v1"
)

// Rollout is a specification for a Rollout resource
#Rollout: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:      #RolloutSpec       @go(Spec) @protobuf(2,bytes,opt)
	status?:   #RolloutStatus     @go(Status) @protobuf(3,bytes,opt)
}

// RolloutSpec is the spec for a Rollout resource
#RolloutSpec: _

// ObjectRef holds a references to the Kubernetes object
#ObjectRef: {
	// API Version of the referent
	apiVersion?: string @go(APIVersion) @protobuf(1,bytes,opt)

	// Kind of the referent
	kind?: string @go(Kind) @protobuf(2,bytes,opt)

	// Name of the referent
	name?: string @go(Name) @protobuf(3,bytes,opt)
}

// DefaultRolloutUniqueLabelKey is the default key of the selector that is added
// to existing ReplicaSets (and label key that is added to its pods) to prevent the existing ReplicaSets
// to select new pods (and old pods being select by new ReplicaSet).
#DefaultRolloutUniqueLabelKey: "rollouts-pod-template-hash"

// DefaultReplicaSetScaleDownDeadlineAnnotationKey is the default key attached to an old stable ReplicaSet after
// the rollout transitioned to a new version. It contains the time when the controller can scale down the RS.
#DefaultReplicaSetScaleDownDeadlineAnnotationKey: "scale-down-deadline"

// ManagedByRolloutKey is the key used to indicate which rollout(s) manage a resource but doesn't own it.
#ManagedByRolloutsKey: "argo-rollouts.argoproj.io/managed-by-rollouts"

// DefaultReplicaSetRestartAnnotationKey indicates that the ReplicaSet with this annotation was restarted at the
// time listed in the value
#DefaultReplicaSetRestartAnnotationKey: "argo-rollouts.argoproj.io/restarted-after"

// LabelKeyControllerInstanceID is the label the controller uses for the rollout, experiment, analysis segregation
// between controllers. Controllers will only operate on objects with the same instanceID as the controller.
#LabelKeyControllerInstanceID: "argo-rollouts.argoproj.io/controller-instance-id"

// RolloutStrategy defines strategy to apply during next rollout
#RolloutStrategy: {
	// +optional
	blueGreen?: null | #BlueGreenStrategy @go(BlueGreen,*BlueGreenStrategy) @protobuf(1,bytes,opt)

	// +optional
	canary?: null | #CanaryStrategy @go(Canary,*CanaryStrategy) @protobuf(2,bytes,opt)
}

// BlueGreenStrategy defines parameters for Blue Green deployment
#BlueGreenStrategy: {
	// Name of the service that the rollout modifies as the active service.
	activeService: string @go(ActiveService) @protobuf(1,bytes,opt)

	// Name of the service that the rollout modifies as the preview service.
	// +optional
	previewService?: string @go(PreviewService) @protobuf(2,bytes,opt)

	// PreviewReplicaCount is the number of replicas to run for the preview stack before the
	// switchover. Once the rollout is resumed the desired replicaset will be full scaled up before the switch occurs
	// +optional
	previewReplicaCount?: null | int32 @go(PreviewReplicaCount,*int32) @protobuf(3,varint,opt)

	// AutoPromotionEnabled indicates if the rollout should automatically promote the new ReplicaSet
	// to the active service or enter a paused state. If not specified, the default value is true.
	// +optional
	autoPromotionEnabled?: null | bool @go(AutoPromotionEnabled,*bool) @protobuf(4,varint,opt)

	// AutoPromotionSeconds is a duration in seconds in which to delay auto-promotion (default: 0).
	// The countdown begins after the preview ReplicaSet have reached full availability.
	// This option is ignored if autoPromotionEnabled is set to false.
	// +optional
	autoPromotionSeconds?: int32 @go(AutoPromotionSeconds) @protobuf(5,varint,opt)

	// MaxUnavailable The maximum number of pods that can be unavailable during a restart operation.
	// Defaults to 25% of total replicas.
	// +optional
	maxUnavailable?: null | intstr.#IntOrString @go(MaxUnavailable,*intstr.IntOrString) @protobuf(6,bytes,opt)

	// ScaleDownDelaySeconds adds a delay before scaling down the previous replicaset.
	// If omitted, the Rollout waits 30 seconds before scaling down the previous ReplicaSet.
	// A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in
	// a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for
	// more information
	// +optional
	scaleDownDelaySeconds?: null | int32 @go(ScaleDownDelaySeconds,*int32) @protobuf(7,varint,opt)

	// ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
	// +optional
	scaleDownDelayRevisionLimit?: null | int32 @go(ScaleDownDelayRevisionLimit,*int32) @protobuf(8,varint,opt)

	// PrePromotionAnalysis configuration to run analysis before a selector switch
	prePromotionAnalysis?: null | #RolloutAnalysis @go(PrePromotionAnalysis,*RolloutAnalysis) @protobuf(9,bytes,opt)

	// AntiAffinity enables anti-affinity rules for Blue Green deployment
	// +optional
	antiAffinity?: null | #AntiAffinity @go(AntiAffinity,*AntiAffinity) @protobuf(10,bytes,opt)

	// PostPromotionAnalysis configuration to run analysis after a selector switch
	postPromotionAnalysis?: null | #RolloutAnalysis @go(PostPromotionAnalysis,*RolloutAnalysis) @protobuf(11,bytes,opt)

	// PreviewMetadata specify labels and annotations which will be attached to the preview pods for
	// the duration which they act as a preview pod, and will be removed after
	previewMetadata?: null | #PodTemplateMetadata @go(PreviewMetadata,*PodTemplateMetadata) @protobuf(12,bytes,opt)

	// ActiveMetadata specify labels and annotations which will be attached to the active pods for
	// the duration which they act as a active pod, and will be removed after
	activeMetadata?: null | #PodTemplateMetadata @go(ActiveMetadata,*PodTemplateMetadata) @protobuf(13,bytes,opt)

	// AbortScaleDownDelaySeconds adds a delay in second before scaling down the preview replicaset
	// if update is aborted. 0 means not to scale down.
	// Default is 30 second
	// +optional
	abortScaleDownDelaySeconds?: null | int32 @go(AbortScaleDownDelaySeconds,*int32) @protobuf(14,varint,opt)
}

// AntiAffinity defines which inter-pod scheduling rule to use for anti-affinity injection
#AntiAffinity: {
	// +optional
	preferredDuringSchedulingIgnoredDuringExecution?: null | #PreferredDuringSchedulingIgnoredDuringExecution @go(PreferredDuringSchedulingIgnoredDuringExecution,*PreferredDuringSchedulingIgnoredDuringExecution) @protobuf(1,bytes,opt)

	// +optional
	requiredDuringSchedulingIgnoredDuringExecution?: null | #RequiredDuringSchedulingIgnoredDuringExecution @go(RequiredDuringSchedulingIgnoredDuringExecution,*RequiredDuringSchedulingIgnoredDuringExecution) @protobuf(2,bytes,opt)
}

// PreferredDuringSchedulingIgnoredDuringExecution defines the weight of the anti-affinity injection
#PreferredDuringSchedulingIgnoredDuringExecution: {
	// Weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	weight: int32 @go(Weight) @protobuf(1,varint,opt)
}

// RequiredDuringSchedulingIgnoredDuringExecution defines inter-pod scheduling rule to be RequiredDuringSchedulingIgnoredDuringExecution
#RequiredDuringSchedulingIgnoredDuringExecution: {
}

// CanaryStrategy defines parameters for a Replica Based Canary
#CanaryStrategy: {
	// CanaryService holds the name of a service which selects pods with canary version and don't select any pods with stable version.
	// +optional
	canaryService?: string @go(CanaryService) @protobuf(1,bytes,opt)

	// StableService holds the name of a service which selects pods with stable version and don't select any pods with canary version.
	// +optional
	stableService?: string @go(StableService) @protobuf(2,bytes,opt)

	// Steps define the order of phases to execute the canary deployment
	// +optional
	steps?: [...#CanaryStep] @go(Steps,[]CanaryStep) @protobuf(3,bytes,rep)

	// TrafficRouting hosts all the supported service meshes supported to enable more fine-grained traffic routing
	trafficRouting?: null | #RolloutTrafficRouting @go(TrafficRouting,*RolloutTrafficRouting) @protobuf(4,bytes,opt)

	// MaxUnavailable The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%).
	// Absolute number is calculated from percentage by rounding down.
	// This can not be 0 if MaxSurge is 0.
	// By default, a fixed value of 25% is used.
	// Example: when this is set to 30%, the old RC can be scaled down by 30%
	// immediately when the rolling update starts. Once new pods are ready, old RC
	// can be scaled down further, followed by scaling up the new RC, ensuring
	// that at least 70% of original number of pods are available at all times
	// during the update.
	// +optional
	maxUnavailable?: null | intstr.#IntOrString @go(MaxUnavailable,*intstr.IntOrString) @protobuf(5,bytes,opt)

	// MaxSurge The maximum number of pods that can be scheduled above the original number of
	// pods.
	// Value can be an absolute number (ex: 5) or a percentage of total pods at
	// the start of the update (ex: 10%). This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up.
	// By default, a value of 25% is used.
	// Example: when this is set to 30%, the new RC can be scaled up by 30%
	// immediately when the rolling update starts. Once old pods have been killed,
	// new RC can be scaled up further, ensuring that total number of pods running
	// at any time during the update is at most 130% of original pods.
	// +optional
	maxSurge?: null | intstr.#IntOrString @go(MaxSurge,*intstr.IntOrString) @protobuf(6,bytes,opt)

	// Analysis runs a separate analysisRun while all the steps execute. This is intended to be a continuous validation of the new ReplicaSet
	analysis?: null | #RolloutAnalysisBackground @go(Analysis,*RolloutAnalysisBackground) @protobuf(7,bytes,opt)

	// AntiAffinity enables anti-affinity rules for Canary deployment
	// +optional
	antiAffinity?: null | #AntiAffinity @go(AntiAffinity,*AntiAffinity) @protobuf(8,bytes,opt)

	// CanaryMetadata specify labels and annotations which will be attached to the canary pods for
	// the duration which they act as a canary, and will be removed after
	canaryMetadata?: null | #PodTemplateMetadata @go(CanaryMetadata,*PodTemplateMetadata) @protobuf(9,bytes,opt)

	// StableMetadata specify labels and annotations which will be attached to the stable pods for
	// the duration which they act as a canary, and will be removed after
	stableMetadata?: null | #PodTemplateMetadata @go(StableMetadata,*PodTemplateMetadata) @protobuf(10,bytes,opt)

	// ScaleDownDelaySeconds adds a delay before scaling down the previous ReplicaSet when the
	// canary strategy is used with traffic routing (default 30 seconds). A delay in scaling down
	// the previous ReplicaSet is needed after switching the stable service selector to point to
	// the new ReplicaSet, in order to give time for traffic providers to re-target the new pods.
	// This value is ignored with basic, replica-weighted canary without traffic routing.
	// +optional
	scaleDownDelaySeconds?: null | int32 @go(ScaleDownDelaySeconds,*int32) @protobuf(11,varint,opt)

	// ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
	// +optional
	scaleDownDelayRevisionLimit?: null | int32 @go(ScaleDownDelayRevisionLimit,*int32) @protobuf(12,varint,opt)

	// AbortScaleDownDelaySeconds adds a delay in second before scaling down the canary pods when update
	// is aborted for canary strategy with traffic routing (not applicable for basic canary).
	// 0 means canary pods are not scaled down.
	// Default is 30 seconds.
	// +optional
	abortScaleDownDelaySeconds?: null | int32 @go(AbortScaleDownDelaySeconds,*int32) @protobuf(13,varint,opt)

	// DynamicStableScale is a traffic routing feature which dynamically scales the stable
	// ReplicaSet to minimize total pods which are running during an update. This is calculated by
	// scaling down the stable as traffic is increased to canary. When disabled (the default behavior)
	// the stable ReplicaSet remains fully scaled to support instantaneous aborts.
	dynamicStableScale?: bool @go(DynamicStableScale) @protobuf(14,varint,opt)

	// PingPongSpec holds the ping and pong services
	pingPong?: null | #PingPongSpec @go(PingPong,*PingPongSpec) @protobuf(15,varint,opt)
}

// PingPongSpec holds the ping and pong service name.
#PingPongSpec: {
	// name of the ping service
	pingService: string @go(PingService) @protobuf(1,bytes,opt)

	// name of the pong service
	pongService: string @go(PongService) @protobuf(2,bytes,opt)
}

// AnalysisRunStrategy configuration for the analysis runs and experiments to retain
#AnalysisRunStrategy: {
	// SuccessfulRunHistoryLimit limits the number of old successful analysis runs and experiments to be retained in a history
	successfulRunHistoryLimit?: null | int32 @go(SuccessfulRunHistoryLimit,*int32) @protobuf(1,varint,opt)

	// UnsuccessfulRunHistoryLimit limits the number of old unsuccessful analysis runs and experiments to be retained in a history.
	// Stages for unsuccessful: "Error", "Failed", "Inconclusive"
	unsuccessfulRunHistoryLimit?: null | int32 @go(UnsuccessfulRunHistoryLimit,*int32) @protobuf(2,varint,opt)
}

// ALBTrafficRouting configuration for ALB ingress controller to control traffic routing
#ALBTrafficRouting: {
	// Ingress refers to the name of an `Ingress` resource in the same namespace as the `Rollout`
	ingress: string @go(Ingress) @protobuf(1,bytes,opt)

	// ServicePort refers to the port that the Ingress action should route traffic to
	servicePort: int32 @go(ServicePort) @protobuf(2,varint,opt)

	// RootService references the service in the ingress to the controller should add the action to
	rootService?: string @go(RootService) @protobuf(3,bytes,opt)

	// AdditionalForwardConfig allows to specify further settings on the ForwaredConfig
	// +optional
	stickinessConfig?: null | #StickinessConfig @go(StickinessConfig,*StickinessConfig) @protobuf(5,bytes,opt)

	// AnnotationPrefix has to match the configured annotation prefix on the alb ingress controller
	// +optional
	annotationPrefix?: string @go(AnnotationPrefix) @protobuf(4,bytes,opt)
}

#StickinessConfig: {
	enabled:         bool  @go(Enabled) @protobuf(1,varint,opt)
	durationSeconds: int64 @go(DurationSeconds) @protobuf(2,varint,opt)
}

// RolloutTrafficRouting hosts all the different configuration for supported service meshes to enable more fine-grained traffic routing
#RolloutTrafficRouting: {
	// Istio holds Istio specific configuration to route traffic
	istio?: null | #IstioTrafficRouting @go(Istio,*IstioTrafficRouting) @protobuf(1,bytes,opt)

	// Nginx holds Nginx Ingress specific configuration to route traffic
	nginx?: null | #NginxTrafficRouting @go(Nginx,*NginxTrafficRouting) @protobuf(2,bytes,opt)

	// Nginx holds ALB Ingress specific configuration to route traffic
	alb?: null | #ALBTrafficRouting @go(ALB,*ALBTrafficRouting) @protobuf(3,bytes,opt)

	// SMI holds TrafficSplit specific configuration to route traffic
	smi?: null | #SMITrafficRouting @go(SMI,*SMITrafficRouting) @protobuf(4,bytes,opt)

	// Ambassador holds specific configuration to use Ambassador to route traffic
	ambassador?: null | #AmbassadorTrafficRouting @go(Ambassador,*AmbassadorTrafficRouting) @protobuf(5,bytes,opt)

	// AppMesh holds specific configuration to use AppMesh to route traffic
	appMesh?: null | #AppMeshTrafficRouting @go(AppMesh,*AppMeshTrafficRouting) @protobuf(6,bytes,opt)
}

// AmbassadorTrafficRouting defines the configuration required to use Ambassador as traffic
// router
#AmbassadorTrafficRouting: {
	// Mappings refer to the name of the Ambassador Mappings used to route traffic to the
	// service
	mappings: [...string] @go(Mappings,[]string) @protobuf(1,bytes,rep)
}

// SMITrafficRouting configuration for TrafficSplit Custom Resource to control traffic routing
#SMITrafficRouting: {
	// RootService holds the name of that clients use to communicate.
	// +optional
	rootService?: string @go(RootService) @protobuf(1,bytes,opt)

	// TrafficSplitName holds the name of the TrafficSplit.
	// +optional
	trafficSplitName?: string @go(TrafficSplitName) @protobuf(2,bytes,opt)
}

// NginxTrafficRouting configuration for Nginx ingress controller to control traffic routing
#NginxTrafficRouting: {
	// AnnotationPrefix has to match the configured annotation prefix on the nginx ingress controller
	// +optional
	annotationPrefix?: string @go(AnnotationPrefix) @protobuf(1,bytes,opt)

	// StableIngress refers to the name of an `Ingress` resource in the same namespace as the `Rollout`
	stableIngress: string @go(StableIngress) @protobuf(2,bytes,opt)

	// +optional
	additionalIngressAnnotations?: {[string]: string} @go(AdditionalIngressAnnotations,map[string]string) @protobuf(3,bytes,rep)
}

// IstioTrafficRouting configuration for Istio service mesh to enable fine grain configuration
#IstioTrafficRouting: {
	// VirtualService references an Istio VirtualService to modify to shape traffic
	virtualService?: null | #IstioVirtualService @go(VirtualService,*IstioVirtualService) @protobuf(1,bytes,opt)

	// DestinationRule references an Istio DestinationRule to modify to shape traffic
	destinationRule?: null | #IstioDestinationRule @go(DestinationRule,*IstioDestinationRule) @protobuf(2,bytes,opt)

	// VirtualServices references a list of Istio VirtualService to modify to shape traffic
	virtualServices?: [...#IstioVirtualService] @go(VirtualServices,[]IstioVirtualService) @protobuf(3,bytes,opt)
}

// IstioVirtualService holds information on the virtual service the rollout needs to modify
#IstioVirtualService: {
	// Name holds the name of the VirtualService
	name: string @go(Name) @protobuf(1,bytes,opt)

	// A list of HTTP routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
	routes?: [...string] @go(Routes,[]string) @protobuf(2,bytes,rep)

	// A list of TLS/HTTPS routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
	tlsRoutes?: [...#TLSRoute] @go(TLSRoutes,[]TLSRoute) @protobuf(3,bytes,rep)
}

// TLSRoute holds the information on the virtual service's TLS/HTTPS routes that are desired to be matched for changing weights.
#TLSRoute: {
	// Port number of the TLS Route desired to be matched in the given Istio VirtualService.
	port?: int64 @go(Port) @protobuf(1,bytes,opt)

	// A list of all the SNI Hosts of the TLS Route desired to be matched in the given Istio VirtualService.
	sniHosts?: [...string] @go(SNIHosts,[]string) @protobuf(2,bytes,rep)
}

// IstioDestinationRule is a reference to an Istio DestinationRule to modify and shape traffic
#IstioDestinationRule: {
	// Name holds the name of the DestinationRule
	name: string @go(Name) @protobuf(1,bytes,opt)

	// CanarySubsetName is the subset name to modify labels with canary ReplicaSet pod template hash value
	canarySubsetName: string @go(CanarySubsetName) @protobuf(2,bytes,opt)

	// StableSubsetName is the subset name to modify labels with stable ReplicaSet pod template hash value
	stableSubsetName: string @go(StableSubsetName) @protobuf(3,bytes,opt)
}

// AppMeshTrafficRouting configuration for AWS AppMesh service mesh to enable fine grain configuration
#AppMeshTrafficRouting: {
	// VirtualService references an AppMesh VirtualService and VirtualRouter to modify to shape traffic
	virtualService?: null | #AppMeshVirtualService @go(VirtualService,*AppMeshVirtualService) @protobuf(1,bytes,opt)

	// VirtualNodeGroup references an AppMesh Route targets that are formed by a set of VirtualNodes that are used to shape traffic
	virtualNodeGroup?: null | #AppMeshVirtualNodeGroup @go(VirtualNodeGroup,*AppMeshVirtualNodeGroup) @protobuf(2,bytes,opt)
}

// AppMeshVirtualService holds information on the virtual service the rollout needs to modify
#AppMeshVirtualService: {
	// Name is the name of virtual service
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Routes is list of HTTP routes within virtual router associated with virtual service to edit. If omitted, virtual service must have a single route of this type.
	routes?: [...string] @go(Routes,[]string) @protobuf(2,bytes,rep)
}

// AppMeshVirtualNodeGroup holds information about targets used for routing traffic to a virtual service
#AppMeshVirtualNodeGroup: {
	// CanaryVirtualNodeRef is the virtual node ref to modify labels with canary ReplicaSet pod template hash value
	canaryVirtualNodeRef?: null | #AppMeshVirtualNodeReference @go(CanaryVirtualNodeRef,*AppMeshVirtualNodeReference) @protobuf(1,bytes,opt)

	// StableVirtualNodeRef is the virtual node name to modify labels with stable ReplicaSet pod template hash value
	stableVirtualNodeRef?: null | #AppMeshVirtualNodeReference @go(StableVirtualNodeRef,*AppMeshVirtualNodeReference) @protobuf(2,bytes,opt)
}

// AppMeshVirtualNodeReference holds a reference to VirtualNode.appmesh.k8s.aws
#AppMeshVirtualNodeReference: {
	// Name is the name of VirtualNode CR
	name: string @go(Name) @protobuf(1,bytes,opt)
}

// RolloutExperimentStep defines a template that is used to create a experiment for a step
#RolloutExperimentStep: {
	// Templates what templates that should be added to the experiment. Should be non-nil
	// +patchMergeKey=name
	// +patchStrategy=merge
	templates: [...#RolloutExperimentTemplate] @go(Templates,[]RolloutExperimentTemplate) @protobuf(1,bytes,rep)

	// Duration is a duration string (e.g. 30s, 5m, 1h) that the experiment should run for
	// +optional
	duration?: #DurationString @go(Duration) @protobuf(2,bytes,opt,casttype=DurationString)

	// Analyses reference which analysis templates to run with the experiment
	// +patchMergeKey=name
	// +patchStrategy=merge
	analyses?: [...#RolloutExperimentStepAnalysisTemplateRef] @go(Analyses,[]RolloutExperimentStepAnalysisTemplateRef) @protobuf(3,bytes,rep)
}

#RolloutExperimentStepAnalysisTemplateRef: {
	// Name is a name for this analysis template invocation
	name: string @go(Name) @protobuf(1,bytes,opt)

	// TemplateName reference of the AnalysisTemplate name used by the Experiment to create the run
	templateName: string @go(TemplateName) @protobuf(2,bytes,opt)

	// Whether to look for the templateName at cluster scope or namespace scope
	// +optional
	clusterScope?: bool @go(ClusterScope) @protobuf(3,varint,opt)

	// Args the arguments that will be added to the AnalysisRuns
	// +patchMergeKey=name
	// +patchStrategy=merge
	args?: [...#AnalysisRunArgument] @go(Args,[]AnalysisRunArgument) @protobuf(4,bytes,rep)

	// RequiredForCompletion blocks the Experiment from completing until the analysis has completed
	requiredForCompletion?: bool @go(RequiredForCompletion) @protobuf(5,varint,opt)
}

// RolloutExperimentTemplate defines the template used to create experiments for the Rollout's experiment canary step
#RolloutExperimentTemplate: {
	// Name description of template that passed to the template
	name: string @go(Name) @protobuf(1,bytes,opt)

	// SpecRef indicates where the rollout should get the RS template from
	specRef: #ReplicaSetSpecRef @go(SpecRef) @protobuf(2,bytes,opt,casttype=ReplicaSetSpecRef)

	// Replicas replica count for the template
	// +optional
	replicas?: null | int32 @go(Replicas,*int32) @protobuf(3,varint,opt)

	// Metadata sets labels and annotations to use for the RS created from the template
	// +optional
	metadata?: #PodTemplateMetadata @go(Metadata) @protobuf(4,bytes,opt)

	// Selector overrides the selector to be used for the template's ReplicaSet. If omitted, will
	// use the same selector as the Rollout
	// +optional
	selector?: null | metav1.#LabelSelector @go(Selector,*metav1.LabelSelector) @protobuf(5,bytes,opt)

	// Weight sets the percentage of traffic the template's replicas should receive
	weight?: null | int32 @go(Weight,*int32) @protobuf(6,varint,opt)
}

// PodTemplateMetadata extra labels to add to the template
#PodTemplateMetadata: {
	// Labels Additional labels to add to the experiment
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(1,bytes,rep)

	// Annotations additional annotations to add to the experiment
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(2,bytes,rep)
}

// ReplicaSetSpecRef defines which RS that the experiment's template will use.
#ReplicaSetSpecRef: string // #enumReplicaSetSpecRef

#enumReplicaSetSpecRef:
	#CanarySpecRef |
	#StableSpecRef

// CanarySpecRef indicates the RS template should be pulled from the newRS's template
#CanarySpecRef: #ReplicaSetSpecRef & "canary"

// StableSpecRef indicates the RS template should be pulled from the stableRS's template
#StableSpecRef: #ReplicaSetSpecRef & "stable"

// CanaryStep defines a step of a canary deployment.
#CanaryStep: {
	// SetWeight sets what percentage of the newRS should receive
	setWeight?: null | int32 @go(SetWeight,*int32) @protobuf(1,varint,opt)

	// Pause freezes the rollout by setting spec.Paused to true.
	// A Rollout will resume when spec.Paused is reset to false.
	// +optional
	pause?: null | #RolloutPause @go(Pause,*RolloutPause) @protobuf(2,bytes,opt)

	// Experiment defines the experiment object that should be created
	experiment?: null | #RolloutExperimentStep @go(Experiment,*RolloutExperimentStep) @protobuf(3,bytes,opt)

	// Analysis defines the AnalysisRun that will run for a step
	analysis?: null | #RolloutAnalysis @go(Analysis,*RolloutAnalysis) @protobuf(4,bytes,opt)

	// SetCanaryScale defines how to scale the newRS without changing traffic weight
	// +optional
	setCanaryScale?: null | #SetCanaryScale @go(SetCanaryScale,*SetCanaryScale) @protobuf(5,bytes,opt)
}

// SetCanaryScale defines how to scale the newRS without changing traffic weight
#SetCanaryScale: {
	// Weight sets the percentage of replicas the newRS should have
	// +optional
	weight?: null | int32 @go(Weight,*int32) @protobuf(1,varint,opt)

	// Replicas sets the number of replicas the newRS should have
	// +optional
	replicas?: null | int32 @go(Replicas,*int32) @protobuf(2,varint,opt)

	// MatchTrafficWeight cancels out previously set Replicas or Weight, effectively activating SetWeight
	// +optional
	matchTrafficWeight?: bool @go(MatchTrafficWeight) @protobuf(3,varint,opt)
}

// RolloutAnalysisBackground defines a template that is used to create a background analysisRun
#RolloutAnalysisBackground: {
	#RolloutAnalysis

	// StartingStep indicates which step the background analysis should start on
	// If not listed, controller defaults to 0
	startingStep?: null | int32 @go(StartingStep,*int32) @protobuf(2,varint,opt)
}

// RolloutAnalysis defines a template that is used to create a analysisRun
#RolloutAnalysis: {
	//Templates reference to a list of analysis templates to combine for an AnalysisRun
	templates?: [...#RolloutAnalysisTemplate] @go(Templates,[]RolloutAnalysisTemplate) @protobuf(1,bytes,rep)

	// Args the arguments that will be added to the AnalysisRuns
	// +patchMergeKey=name
	// +patchStrategy=merge
	args?: [...#AnalysisRunArgument] @go(Args,[]AnalysisRunArgument) @protobuf(2,bytes,rep)

	// DryRun object contains the settings for running the analysis in Dry-Run mode
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	dryRun?: [...#DryRun] @go(DryRun,[]DryRun) @protobuf(3,bytes,rep)

	// MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	measurementRetention?: [...#MeasurementRetention] @go(MeasurementRetention,[]MeasurementRetention) @protobuf(4,bytes,rep)
}

#RolloutAnalysisTemplate: {
	//TemplateName name of template to use in AnalysisRun
	// +optional
	templateName: string @go(TemplateName) @protobuf(1,bytes,opt)

	// Whether to look for the templateName at cluster scope or namespace scope
	// +optional
	clusterScope?: bool @go(ClusterScope) @protobuf(2,varint,opt)
}

// AnalysisRunArgument argument to add to analysisRun
#AnalysisRunArgument: {
	// Name argument name
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Value a hardcoded value for the argument. This field is a one of field with valueFrom
	value?: string @go(Value) @protobuf(2,bytes,opt)

	// ValueFrom A reference to where the value is stored. This field is a one of field with valueFrom
	valueFrom?: null | #ArgumentValueFrom @go(ValueFrom,*ArgumentValueFrom) @protobuf(3,bytes,opt)
}

// ArgumentValueFrom defines references to fields within resources to grab for the value (i.e. Pod Template Hash)
#ArgumentValueFrom: {
	// PodTemplateHashValue gets the value from one of the children ReplicaSet's Pod Template Hash
	podTemplateHashValue?: null | #ValueFromPodTemplateHash @go(PodTemplateHashValue,*ValueFromPodTemplateHash) @protobuf(1,bytes,opt,casttype=ValueFromPodTemplateHash)

	//FieldRef
	fieldRef?: null | #FieldRef @go(FieldRef,*FieldRef) @protobuf(2,bytes,opt)
}

#FieldRef: {
	// Required: Path of the field to select in the specified API version
	fieldPath: string @go(FieldPath) @protobuf(1,bytes,opt)
}

// ValueFromPodTemplateHash indicates which ReplicaSet pod template pod hash to use
#ValueFromPodTemplateHash: string // #enumValueFromPodTemplateHash

#enumValueFromPodTemplateHash:
	#Stable |
	#Latest

// Stable tells the Rollout to get the pod template hash from the stable ReplicaSet
#Stable: #ValueFromPodTemplateHash & "Stable"

// Latest tells the Rollout to get the pod template hash from the latest ReplicaSet
#Latest: #ValueFromPodTemplateHash & "Latest"

// RolloutTypeLabel indicates how the rollout created the analysisRun
#RolloutTypeLabel: "rollout-type"

// RolloutTypeStepLabel indicates that the analysisRun was created as a canary step
#RolloutTypeStepLabel: "Step"

// RolloutTypeBackgroundRunLabel indicates that the analysisRun was created in Background to an execution
#RolloutTypeBackgroundRunLabel: "Background"

// RolloutTypePrePromotionLabel indicates that the analysisRun was created before the active service promotion
#RolloutTypePrePromotionLabel: "PrePromotion"

// RolloutTypePostPromotionLabel indicates that the analysisRun was created after the active service promotion
#RolloutTypePostPromotionLabel: "PostPromotion"

// RolloutCanaryStepIndexLabel indicates which step created this analysisRun
#RolloutCanaryStepIndexLabel: "step-index"

// RolloutPause defines a pause stage for a rollout
#RolloutPause: {
	// Duration the amount of time to wait before moving to the next step.
	// +optional
	duration?: null | intstr.#IntOrString @go(Duration,*intstr.IntOrString) @protobuf(1,bytes,opt)
}

// PauseReason reasons that the rollout can pause
#PauseReason: string // #enumPauseReason

#enumPauseReason:
	#PauseReasonInconclusiveAnalysis |
	#PauseReasonInconclusiveExperiment |
	#PauseReasonCanaryPauseStep |
	#PauseReasonBlueGreenPause

// PauseReasonInconclusiveAnalysis pauses rollout when rollout has an inconclusive analysis run
#PauseReasonInconclusiveAnalysis: #PauseReason & "InconclusiveAnalysisRun"

// PauseReasonInconclusiveExperiment pauses rollout when rollout has an inconclusive experiment
#PauseReasonInconclusiveExperiment: #PauseReason & "InconclusiveExperiment"

// PauseReasonCanaryPauseStep pause rollout for canary pause step
#PauseReasonCanaryPauseStep: #PauseReason & "CanaryPauseStep"

// PauseReasonBlueGreenPause pause rollout before promoting rollout
#PauseReasonBlueGreenPause: #PauseReason & "BlueGreenPause"

// PauseCondition the reason for a pause and when it started
#PauseCondition: {
	reason:    #PauseReason @go(Reason) @protobuf(1,bytes,opt,casttype=PauseReason)
	startTime: metav1.#Time @go(StartTime) @protobuf(2,bytes,opt)
}

// RolloutPhase are a set of phases that this rollout
#RolloutPhase: string // #enumRolloutPhase

#enumRolloutPhase:
	#RolloutPhaseHealthy |
	#RolloutPhaseDegraded |
	#RolloutPhaseProgressing |
	#RolloutPhasePaused

// RolloutPhaseHealthy indicates a rollout is healthy
#RolloutPhaseHealthy: #RolloutPhase & "Healthy"

// RolloutPhaseDegraded indicates a rollout is degraded (e.g. pod unavailability, misconfiguration)
#RolloutPhaseDegraded: #RolloutPhase & "Degraded"

// RolloutPhaseProgressing indicates a rollout is not yet healthy but still making progress towards a healthy state
#RolloutPhaseProgressing: #RolloutPhase & "Progressing"

// RolloutPhasePaused indicates a rollout is not yet healthy and will not make progress until unpaused
#RolloutPhasePaused: #RolloutPhase & "Paused"

// RolloutStatus is the status for a Rollout resource
#RolloutStatus: {
	// Abort cancel the current rollout progression
	abort?: bool @go(Abort) @protobuf(1,varint,opt)

	// PauseConditions is a list of reasons why rollout became automatically paused (e.g.
	// CanaryPauseStep, BlueGreenPause, InconclusiveAnalysis). The items in this list are populated
	// by the controller but are cleared by the user (e.g. plugin, argo-cd resume action) when they
	// wish to unpause. If pause conditions is empty, but controllerPause is true, it indicates
	// the user manually unpaused the Rollout
	pauseConditions?: [...#PauseCondition] @go(PauseConditions,[]PauseCondition) @protobuf(2,bytes,rep)

	// ControllerPause indicates the controller has paused the rollout. It is set to true when
	// the controller adds a pause condition. This field helps to discern the scenario where a
	// rollout was resumed after being paused by the controller (e.g. via the plugin). In that
	// situation, the pauseConditions would have been cleared , but controllerPause would still be
	// set to true.
	controllerPause?: bool @go(ControllerPause) @protobuf(3,varint,opt)

	// AbortedAt indicates the controller reconciled an aborted rollout. The controller uses this to understand if
	// the controller needs to do some specific work when a Rollout is aborted. For example, the reconcileAbort is used
	// to indicate if the Rollout should enter an aborted state when the latest AnalysisRun is a failure, or the controller
	// has already put the Rollout into an aborted and should create a new AnalysisRun.
	abortedAt?: null | metav1.#Time @go(AbortedAt,*metav1.Time) @protobuf(4,bytes,opt)

	// CurrentPodHash the hash of the current pod template
	// +optional
	currentPodHash?: string @go(CurrentPodHash) @protobuf(5,bytes,opt)

	// CurrentStepHash the hash of the current list of steps for the current strategy. This is used to detect when the
	// list of current steps change
	// +optional
	currentStepHash?: string @go(CurrentStepHash) @protobuf(6,bytes,opt)

	// Total number of non-terminated pods targeted by this rollout (their labels match the selector).
	// +optional
	replicas?: int32 @go(Replicas) @protobuf(7,varint,opt)

	// Total number of non-terminated pods targeted by this rollout that have the desired template spec.
	// +optional
	updatedReplicas?: int32 @go(UpdatedReplicas) @protobuf(8,varint,opt)

	// Total number of ready pods targeted by this rollout.
	// +optional
	readyReplicas?: int32 @go(ReadyReplicas) @protobuf(9,varint,opt)

	// Total number of available pods (ready for at least minReadySeconds) targeted by this rollout.
	// +optional
	availableReplicas?: int32 @go(AvailableReplicas) @protobuf(10,varint,opt)

	// CurrentStepIndex defines the current step of the rollout is on. If the current step index is null, the
	// controller will execute the rollout.
	// +optional
	currentStepIndex?: null | int32 @go(CurrentStepIndex,*int32) @protobuf(11,varint,opt)

	// Count of hash collisions for the Rollout. The Rollout controller uses this
	// field as a collision avoidance mechanism when it needs to create the name for the
	// newest ReplicaSet.
	// +optional
	collisionCount?: null | int32 @go(CollisionCount,*int32) @protobuf(12,varint,opt)

	// The generation observed by the rollout controller from metadata.generation
	// +optional
	observedGeneration?: string @go(ObservedGeneration) @protobuf(13,bytes,opt)

	// Conditions a list of conditions a rollout can have.
	// +optional
	conditions?: [...#RolloutCondition] @go(Conditions,[]RolloutCondition) @protobuf(14,bytes,rep)

	// Canary describes the state of the canary rollout
	// +optional
	canary?: #CanaryStatus @go(Canary) @protobuf(15,bytes,opt)

	// BlueGreen describes the state of the bluegreen rollout
	// +optional
	blueGreen?: #BlueGreenStatus @go(BlueGreen) @protobuf(16,bytes,opt)

	// HPAReplicas the number of non-terminated replicas that are receiving active traffic
	// +optional
	HPAReplicas?: int32 @protobuf(17,varint,opt)

	// Selector that identifies the pods that are receiving active traffic
	// +optional
	selector?: string @go(Selector) @protobuf(18,bytes,opt)

	// StableRS indicates the replicaset that has successfully rolled out
	// +optional
	stableRS?: string @go(StableRS) @protobuf(19,bytes,opt)

	// RestartedAt indicates last time a Rollout was restarted
	restartedAt?: null | metav1.#Time @go(RestartedAt,*metav1.Time) @protobuf(20,bytes,opt)

	// PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses.
	promoteFull?: bool @go(PromoteFull) @protobuf(21,varint,opt)

	// Phase is the rollout phase. Clients should only rely on the value if status.observedGeneration equals metadata.generation
	phase?: #RolloutPhase @go(Phase) @protobuf(22,bytes,opt,casttype=RolloutPhase)

	// Message provides details on why the rollout is in its current phase
	message?: string @go(Message) @protobuf(23,bytes,opt)

	// The generation of referenced workload observed by the rollout controller
	// +optional
	workloadObservedGeneration?: string @go(WorkloadObservedGeneration) @protobuf(24,bytes,opt)

	/// ALB keeps information regarding the ALB and TargetGroups
	alb?: null | #ALBStatus @go(ALB,*ALBStatus) @protobuf(25,bytes,opt)
}

// BlueGreenStatus status fields that only pertain to the blueGreen rollout
#BlueGreenStatus: {
	// PreviewSelector indicates which replicas set the preview service is serving traffic to
	// +optional
	previewSelector?: string @go(PreviewSelector) @protobuf(1,bytes,opt)

	// ActiveSelector indicates which replicas set the active service is serving traffic to
	// +optional
	activeSelector?: string @go(ActiveSelector) @protobuf(2,bytes,opt)

	// ScaleUpPreviewCheckPoint indicates that the Replicaset receiving traffic from the preview service is ready to be scaled up after the rollout is unpaused
	// +optional
	scaleUpPreviewCheckPoint?: bool @go(ScaleUpPreviewCheckPoint) @protobuf(3,varint,opt)

	// PrePromotionAnalysisRunStatus indicates the status of the current prepromotion analysis run
	prePromotionAnalysisRunStatus?: null | #RolloutAnalysisRunStatus @go(PrePromotionAnalysisRunStatus,*RolloutAnalysisRunStatus) @protobuf(4,bytes,opt)

	// PostPromotionAnalysisRunStatus indicates the status of the current post promotion analysis run
	postPromotionAnalysisRunStatus?: null | #RolloutAnalysisRunStatus @go(PostPromotionAnalysisRunStatus,*RolloutAnalysisRunStatus) @protobuf(5,bytes,opt)
}

// CanaryStatus status fields that only pertain to the canary rollout
#CanaryStatus: {
	// CurrentStepAnalysisRunStatus indicates the status of the current step analysis run
	currentStepAnalysisRunStatus?: null | #RolloutAnalysisRunStatus @go(CurrentStepAnalysisRunStatus,*RolloutAnalysisRunStatus) @protobuf(1,bytes,opt)

	// CurrentBackgroundAnalysisRunStatus indicates the status of the current background analysis run
	currentBackgroundAnalysisRunStatus?: null | #RolloutAnalysisRunStatus @go(CurrentBackgroundAnalysisRunStatus,*RolloutAnalysisRunStatus) @protobuf(2,bytes,opt)

	// CurrentExperiment indicates the running experiment
	currentExperiment?: string @go(CurrentExperiment) @protobuf(3,bytes,opt)

	// Weights records the weights which have been set on traffic provider. Only valid when using traffic routing
	weights?: null | #TrafficWeights @go(Weights,*TrafficWeights) @protobuf(4,bytes,opt)

	// StablePingPong For the ping-pong feature holds the current stable service, ping or pong
	stablePingPong?: #PingPongType @go(StablePingPong) @protobuf(5,bytes,opt)
}

#PingPongType: string // #enumPingPongType

#enumPingPongType:
	#PPPing |
	#PPPong

#PPPing: #PingPongType & "ping"
#PPPong: #PingPongType & "pong"

// TrafficWeights describes the current status of how traffic has been split
#TrafficWeights: {
	// Canary is the current traffic weight split to canary ReplicaSet
	canary: #WeightDestination @go(Canary) @protobuf(1,bytes,opt)

	// Stable is the current traffic weight split to stable ReplicaSet
	stable: #WeightDestination @go(Stable) @protobuf(2,bytes,opt)

	// Additional holds the weights split to additional ReplicaSets such as experiment ReplicaSets
	additional?: [...#WeightDestination] @go(Additional,[]WeightDestination) @protobuf(3,bytes,rep)

	// Verified is an optional indicator that the weight has been verified to have taken effect.
	// This is currently only applicable to ALB traffic router
	verified?: null | bool @go(Verified,*bool) @protobuf(4,bytes,opt)
}

#WeightDestination: {
	// Weight is an percentage of traffic being sent to this destination
	weight: int32 @go(Weight) @protobuf(1,varint,opt)

	// ServiceName is the Kubernetes service name traffic is being sent to
	serviceName?: string @go(ServiceName) @protobuf(2,bytes,opt)

	// PodTemplateHash is the pod template hash label for this destination
	podTemplateHash?: string @go(PodTemplateHash) @protobuf(3,bytes,opt)
}

#RolloutAnalysisRunStatus: {
	name:     string         @go(Name) @protobuf(1,bytes,opt)
	status:   #AnalysisPhase @go(Status) @protobuf(2,bytes,opt,casttype=AnalysisPhase)
	message?: string         @go(Message) @protobuf(3,bytes,opt)
}

#ALBStatus: {
	loadBalancer?:      #AwsResourceRef @go(LoadBalancer) @protobuf(1,bytes,opt)
	canaryTargetGroup?: #AwsResourceRef @go(CanaryTargetGroup) @protobuf(2,bytes,opt)
	stableTargetGroup?: #AwsResourceRef @go(StableTargetGroup) @protobuf(3,bytes,opt)
}

#AwsResourceRef: {
	name: string @go(Name) @protobuf(1,bytes,opt)
	arn:  string @go(ARN) @protobuf(2,bytes,opt)
}

// RolloutConditionType defines the conditions of Rollout
#RolloutConditionType: string // #enumRolloutConditionType

#enumRolloutConditionType:
	#InvalidSpec |
	#RolloutAvailable |
	#RolloutProgressing |
	#RolloutReplicaFailure |
	#RolloutPaused |
	#RolloutCompleted

// InvalidSpec means the rollout has an invalid spec and will not progress until
// the spec is fixed.
#InvalidSpec: #RolloutConditionType & "InvalidSpec"

// RolloutAvailable means the rollout is available, ie. the active service is pointing at a
// replicaset with the required replicas up and running for at least minReadySeconds.
#RolloutAvailable: #RolloutConditionType & "Available"

// RolloutProgressing means the rollout is progressing. Progress for a rollout is
// considered when a new replica set is created or adopted, when pods scale
// up or old pods scale down, or when the services are updated. Progress is not estimated
// for paused rollouts.
#RolloutProgressing: #RolloutConditionType & "Progressing"

// RolloutReplicaFailure ReplicaFailure is added in a deployment when one of its pods
// fails to be created or deleted.
#RolloutReplicaFailure: #RolloutConditionType & "ReplicaFailure"

// RolloutPaused means that rollout is in a paused state. It is still progressing at this point.
#RolloutPaused: #RolloutConditionType & "Paused"

// RolloutCompleted means that rollout is in a completed state. It is still progressing at this point.
#RolloutCompleted: #RolloutConditionType & "Completed"

// RolloutCondition describes the state of a rollout at a certain point.
#RolloutCondition: {
	// Type of deployment condition.
	type: #RolloutConditionType @go(Type) @protobuf(1,bytes,opt,casttype=RolloutConditionType)

	// Phase of the condition, one of True, False, Unknown.
	status: corev1.#ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=k8s.io/api/core/v1.ConditionStatus)

	// The last time this condition was updated.
	lastUpdateTime: metav1.#Time @go(LastUpdateTime) @protobuf(3,bytes,opt)

	// Last time the condition transitioned from one status to another.
	lastTransitionTime: metav1.#Time @go(LastTransitionTime) @protobuf(4,bytes,opt)

	// The reason for the condition's last transition.
	reason: string @go(Reason) @protobuf(5,bytes,opt)

	// A human readable message indicating details about the transition.
	message: string @go(Message) @protobuf(6,bytes,opt)
}

// RolloutList is a list of Rollout resources
#RolloutList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#Rollout] @go(Items,[]Rollout) @protobuf(2,bytes,rep)
}
